<html>
	<head>
		<h1>CS 184 Project 1 Write-Up</h1>
	</head>
	<body>
		<h2>Overview</h2>
		<p>
			In this project, we implemented a triangle rasterizer, simple matrix transform functions, and various antialising methods, namely sampling rate adjustment, pixel sampling, and level sampling. We gained insight on the speed, memory, and antialiasing tradeoffs for each method. We also gained experience working with barycentric coordinates, mipmaps, and the CGL library. 
		</p>
		
		<!-- TASK 1 -->
		<h2>
			Task 1: Drawing Single-Color Triangles
		</h2>
		<p>
			To rasterize a triangle, we iterate through each sample point and perform the point-in-triangle test, which uses each edge of the triangle as the 3 line functions. If the point is inside the triangle, then all 3 functions will have a value >= 0. We generate the 3 line functions in both the clockwise and counterclockwise direction to capture the case where the normal vectors for all line functions point towards the inside of the triangle. Lastly, we call fill_pixel to fill the corresponding pixel at the given sample point. 
			<br/><br/>
			Our algorithm calculates the bounding box of the triangle by taking the minimum and maximum of the x, y coordinates of the three points.  This prevents us from having to sample the whole image.
		</p>
		<figure>
			<img src='assets/basic_test4_ss1.png' width=500 alt='basic_test4_ss1.png'/>
			<figcaption>basic/test4.svg</figcaption>
		</figure>

		<!-- TASK 2 -->
		<h2>
			Task 2: Antialiasing by Supersampling
		</h2>
		<p>
			Supersampling is useful because we can sample more points per pixel and average the sample values to get the final value for each pixel. When a pixel is partially within a triangle, it will be colored according to the proportion of supersamples within the triangle, rather colored completely by the triangle color. We thus we have more data to reduce rendering artifacts and smoothen lines (reduce jaggies). 			
			<br/><br/>
			Our supersampling algorithm is based on the implementation of task 1 where we have a nested for loop to sample each point. But instead of sampling one point per pixel, we sample more points by incrementing x and y by `1/sqrt(sample_rate)`, rather than 1. For example, if the sampling rate is 4, we sample 4 times per pixel by incrementing x and y by 0.5 instead 1. We store these supersampled points inside `sample_buffer`, which we resized from dimensions `width * height`  to `width * height * sample_rate`. In the function `resolve_to_framebuffer`, we transfer the sample points in `sample_buffer` to the `rgb_framebuffer_target`, which is the actual buffer vector for the color pixel. We add up the color values from `sample_buffer` and divide the total by `sample_rate` to get the average value of the points we super sampled. For points and lines, we changed `fill_pixel` so that if we are rasterizing a point, we will fill in the `sample_buffer` multiple times with the same color value so that when we average the `sample_buffer` in the function `resolve_to_framebuffer`, we will still get the same value for points and lines. The accessing pattern for sample_buffer is 
			sample_buffer[(y + sy) * width * sqrt(sample_rate) + x + sx]
			where x and y = the actual pixel coordinate, sx and sy = the indexes of the extra points we super-sample. We also changed `set_sample_rate` and `set_framebuffer_target` to account for the `sample_rate` when resizing the `sample_buffer`:
			this->sample_buffer.resize(width * height * sample_rate, Color::White)		</p>
		<figure>
			<img src='assets/basic_test4_ss1.png' width=500 alt='basic_test4_ss1.png'/>
			<figcaption>basic/test4.svg</figcaption>
		</figure>
		
		
	</body>
</html>